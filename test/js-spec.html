<!doctype html>
<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
	<script src="../bower_components/webcomponentsjs/webcomponents-lite.js"></script>
	<script src="../bower_components/web-component-tester/browser.js"></script>

	<!-- Step 1: import the element to test -->
	<link rel="import" href="../bower_components/ramda-import/ramda-import.html">
	<link rel="import" href="../bower_components/lodash-import/lodash-import.html">
	<link rel="import" href="../components/eval-ps.html">
	<link rel="import" href="../components/reduce.html">
</head>
<body>
	<script>
		window.addEventListener('WebComponentsReady', function () {
			var checkResult = function (script, expectedResult, message) {
				it(JSON.stringify(script) + " => result = " + JSON.stringify(expectedResult) + " // " + message, function () {
					//var rewritten = rewrite(evalCs(script).result);
					var result = PatternScript.reduce(/*rewrite(*/PatternScript.evalPs(script).result/*)*/);

					expect(result).to.deep.equal(expectedResult);
				});
			};
			
			checkResult({
				"result": "2"
			}, 2, "number");
			
			checkResult({
				"result": "([] 2)"
			}, [2], "single member array");
			
			checkResult({
				"result": "([] 2 3)"
			}, [2, 3], "multi-member array");
			
			checkResult({
				"result": "[] 2 3"
			}, [2, 3], "array assignment without brackets");
			/*
			checkResult({
				"result": "[] ([] 1 2 3)"
			}, [[1,2,3]], "embedded array");
			*/
			checkResult({
				"result": "[] 2 (+ 1 2) 4"
			}, [2, 3, 4], "evaluation within root level bracketless array");

			checkResult({
				"result": "([] 2 (+ 1 2) 4)"
			}, [2, 3, 4], "evaluation within root level bracketed array");

			checkResult({
				"result": "'hello'"
			}, "hello", "string literal");

			checkResult({
				"result": "(+ 2 3)"
			}, 5, "bracketted function application");

			checkResult({
				"result": "+ 2 3"
			}, 5, "bracketless function application");

			checkResult({
				"result": "(- 10 (* 2 3))"
			}, 4, "compound expression");

			checkResult({
				"two"	: "2",
				"result": "(+ two 1)"
			}, 3, "local expression");

			checkResult({
				"result": "((+ 2) 3)"
			}, 5, "partial application");

			checkResult({
				"plus2"	: "(+ 2)",
				"result": "(plus2 3)"
			}, 5, "local partial");
			
			checkResult({
				"plus"	: "+",
				"result": "(plus 2 3)"
			}, 5, "js function assignment");
			
			checkResult({
				"square x"	: "(* x x)",
				"result"	: "(square 3)"
			}, 9, "named parameters");
			
			checkResult({
				"result": "(Math.sqrt 9)"
			}, 3, "js namespace functions");
			
			checkResult({
				"plus x y"	: "(+ x y)",
				"result"	: "plus 2 3"
			}, 5, "define multiple function arguments");
			
			checkResult({
				"hypotenuse x y": "(Math.sqrt (+ (* x x) (* y y)))",
				"result": "((hypotenuse 3) 4)"
			}, 5, "partial application of lisp functions (no rewrite possible)");
			
			checkResult({
				"result": "(_.isNumber 3)"
			}, true, "access to external namespaces");
			
			checkResult({
				"result": "(R.reduce + 0 ([] 1 2 3))"
			}, 6, "passing js functions to higher order js function");
			
			checkResult({
				"square x"	: "(* x x)",
				"result"	: "(R.map square ([] 2 3))"
			}, [4, 9], "pass lisp function higher order js function");
			
			checkResult({
				"factorial x"	: "if (< x 2) 1 (* x (factorial (- x 1))",
				"result"		: "factorial 4"
			}, 24, "recursive lisp function");
			
			checkResult({
				"match 1"	: "'too low'",
				"match x"	: "x",
				"result"	: "match 1"
			}, "too low", "pattern match against constant");

			checkResult({
				"match 1"	: "'too low'",
				"match x"	: "x",
				"result"	: "match 2"
			}, 2, "pattern match against trivial variable");

			checkResult({
				"match 1"	: "'too low'",
				"match x"	: "(* x x)",
				"result"	: "match 2"
			}, 4, "pattern match against ast equation");

			checkResult({
				"match 1"	: "'matched'",
				"match _"	: "'default'",
				"result"	: "match 2"
			}, 'default', "pattern match fallthrough default");

			checkResult({
				"match 1"	: "'matched'",
				"result"	: "match 2"
			}, undefined, "pattern match returns undefined when patterns exhausted");
			
			checkResult({
				"match ([] 0 0 0)"	: "0",
				"match ([] a b c)"	: "+ (+ a b) c",
				"result"			: "match ([] 1 2 3)"
			}, 6, "pattern match deconstructs list");

			checkResult({
				"(match ([] 0 0 0))"	: "0",
				"(match ([] a b c))"	: "(+ (+ a b) c)",
				"result"				: "match ([] 1 2 3)"
			}, 6, "pattern match with braced left-hand-side");

			checkResult({
				"reciprocal 0 _"	: "'undefined'",
				"reciprocal x y"	: "/ y x",
				"half"				: "reciprocal 2",
				"result"			: "half 10"
			}, 5, "curried pattern match 1");

			checkResult({
				"reciprocal 0 _": "'undefined'",
				"reciprocal x y": "/ y x",
				"divideByZero": "reciprocal 0",
				"result": "divideByZero 10"
			}, 'undefined', "curried pattern match 2");

			checkResult({
				"match a 2 b"	: "+ a b",
				"result"		: "match 1 2 3"
			}, 4, "match literals in a list");

			checkResult({
				"match a 1 b"	: "+ a b",
				"result"		: "match 1 2 3"
			}, undefined, "rejects integer mismatch in list");

			checkResult({
				"match ([] a b)"	: "+ a b",
				"result"			: "match (1 2 3)"
			}, undefined, "rejects mismatched arguments in a list");

			checkResult({
				"match a b"	: "* b b",
				"result"	: "match 1 2 3"
			}, 4, "non-pattern matched function ignores extra arguments");

			checkResult({
				"match 1 b"	: "* b b",
				"result"	: "match 1 2 3"
			}, undefined, "pattern matched function fails on extra arguments");
			/*
			checkResult({
				"match ([] a)"	: "a",
				"result"	: "[] ([] 1 2 3)"
			}, [1, 2, 3], "match embedded list in a list");
			*/
			
			checkResult({
				"result": "(if true 10 (/ 1 0))"
			}, 10, "macro execution");
			
		});
	</script>
</body>
</html>
